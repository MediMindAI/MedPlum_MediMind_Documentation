# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## ⚠️ MANDATORY: Theme Colors

**ALWAYS use the official EMR theme colors defined in `THEME_COLORS.md` when building any UI components, styles, or documentation elements.**

Before writing ANY CSS or styling code:
1. Read `THEME_COLORS.md` at the project root
2. Use the defined CSS custom properties (`--emr-*` variables)
3. Never hardcode hex values - always reference the theme

### Quick Reference (See THEME_COLORS.md for full details)
```css
/* Primary Blues */
--emr-primary: #1a365d;           /* Deep navy - primary buttons, headers */
--emr-secondary: #2b6cb0;         /* Vibrant blue - secondary actions */
--emr-accent: #63b3ed;            /* Light blue - highlights, focus states */

/* Gradients */
--emr-gradient-primary: linear-gradient(135deg, #1a365d 0%, #2b6cb0 50%, #3182ce 100%);
--emr-gradient-secondary: linear-gradient(135deg, #2b6cb0 0%, #3182ce 50%, #63b3ed 100%);

/* Text */
--emr-text-primary: #1f2937;      /* Primary text */
--emr-text-secondary: #6b7280;    /* Secondary text */
--emr-text-inverse: #ffffff;      /* White text on dark backgrounds */
```

**This applies to:**
- All CSS changes
- Documentation site styling
- Screenshot annotations
- Any UI mockups or diagrams
- medimind-doc-writer agent work

## Project Overview

This is the **MediMind EMR Patient Registration Documentation** site - a static multi-language documentation website for the MediMind Electronic Medical Records system. It documents the patient registration module built on FHIR/Medplum.

## Development Commands

```bash
# Start local development server (required for fetch API)
python3 -m http.server 8000

# View documentation site
open http://localhost:8000
```

**Important Notes:**
- Always use port 8000 for the documentation site
- The MediMind EMR platform (for testing and taking screenshots) runs on http://localhost:3000/
- Opening `index.html` directly via `file://` will not work due to CORS restrictions on the fetch API used for dynamic section loading

## Architecture

### Manifest-Driven System

The site uses a config-driven architecture defined in `config/manifest.json`:
- All sections, categories, and hierarchy defined in manifest
- No code changes needed to add/remove sections
- Supports hash-based routing: `#/category/section/anchor`

### Multi-language System (i18n)

The site supports three languages: Georgian (ka), English (en), and Russian (ru).

**Modular Translation Files** (preferred):
```
i18n/
├── en/
│   ├── core.json    # UI strings (header, search, loading, buttons)
│   ├── toc.json     # Navigation labels
│   └── meta.json    # Language metadata, hero section
├── ka/
│   └── (same structure)
└── ru/
    └── (same structure)
```

**Legacy Fallback**: `i18n/{ka,en,ru}.json` - Single file per language (auto-fallback if modules fail)

**Other i18n resources**:
- **Section content**: `sections/{ka,en,ru}/*.html` - Actual documentation content
- **Language-specific images**: `images/*-{ka,en,ru}.png` - Screenshots per language

The `I18n` module (`js/i18n.js`) handles:
- Language detection (localStorage → browser → default 'ka')
- Modular translation loading with legacy fallback
- Translation application via `data-i18n` attributes
- Image switching via `data-i18n-img` attributes

### Content Loading

Sections are dynamically loaded by `SectionLoader` (`js/section-loader.js`):
1. Reads section list from `config/manifest.json`
2. Loads high-priority sections first, preloads rest in background
3. Uses LRU cache with TTL for performance
4. Sub-sections loaded into containers (e.g., `architecture-technical`)

### Search System

Search items are auto-generated by `SearchIndexer` (`js/core/search-indexer.js`):
- Extracts headings from loaded section HTML
- No hardcoded search items needed
- Rebuilds automatically on language switch

### JavaScript Modules

**Core Modules** (`js/core/`):
| File | Purpose |
|------|---------|
| `cache.js` | LRU cache with TTL (25 items, 50MB, 30min) |
| `manifest-loader.js` | Loads and parses config/manifest.json |
| `router.js` | Hash-based routing with legacy anchor support |
| `search-indexer.js` | Auto-extracts search items from section HTML |

**Main Modules** (`js/`):
| File | Purpose |
|------|---------|
| `i18n.js` | Language switching, modular translation system |
| `toc-generator.js` | Generates TOC dynamically from manifest |
| `section-loader.js` | Dynamic HTML section loading with caching |
| `docs.js` | Navigation, FAQ accordion, smooth scroll |
| `page.js` | Mermaid diagrams, search modal, sidebar, lightbox |

### CSS Structure

Modular CSS in `css/parts/`:
- `01-variables.css` - Design tokens (colors, gradients, animations)
- `02-header.css` through `12-responsive.css` - Component-specific styles
- `13-lazy-loading.css` - Skeleton loaders and fade animations

## Key Patterns

### Adding New Sections (Config Only - No Code Changes)

1. Create section HTML files:
   ```
   sections/ka/new-section.html
   sections/en/new-section.html
   sections/ru/new-section.html
   ```

2. Add to `config/manifest.json`:
   ```json
   {
     "id": "new-section",
     "titleKey": "toc.newSection",
     "file": "new-section",
     "priority": "medium"
   }
   ```

3. Add translation key to `i18n/{lang}/toc.json`:
   ```json
   {
     "toc": {
       "newSection": "New Section"
     }
   }
   ```

Search items are auto-generated from section headings.

### Adding Translations
1. Add keys to modular files: `i18n/{lang}/core.json`, `toc.json`, or `meta.json`
2. Use `data-i18n="key.path"` on elements for text content
3. Use `data-i18n-attr="placeholder"` to translate attributes
4. For images: `data-i18n-img="basename"` → loads `images/basename-{lang}.png`

### Mermaid Diagrams
Diagrams use Mermaid.js with a custom dark theme configured in `js/page.js`. Zoomable diagrams use class `mermaid-zoomable` inside `mermaid-container`.

## Screenshot Workflow (Using Playwright Tools)

**Always use the medimind-doc-writer agent** for capturing EMR screenshots. The agent uses Playwright tools interactively (not automated scripts).

### Key Principles

1. **Analyze before capturing** - Use `evaluate` to understand the DOM structure
2. **Click language buttons** - Don't use localStorage; click actual ENG/RUS/ქარ buttons
3. **Verify every screenshot** - Read the image file to confirm correct content
4. **Test documentation** - After adding images, verify they render correctly

### EMR Application Details

| Item | Value |
|------|-------|
| URL | `http://localhost:3005` (check ports 3000-3005) |
| Login | `admin@medimind.ge` / `MediMind2024` |
| Language buttons | `button:has-text('ENG')`, `button:has-text('RUS')`, `button:has-text('ქარ')` |
| Registration page | `/emr/registration/registration` |

### Screenshot Naming Convention

```
images/{feature-name}-{lang}.png

Examples:
- hero-search-en.png
- desktop-sidebar-ka.png
- insurance-section-ru.png
```

### Verification Checklist

After capturing screenshots and adding to documentation:
- [ ] Each image shows correct language
- [ ] Each image shows correct feature/section
- [ ] Aspect ratios are reasonable (not too wide/narrow)
- [ ] Documentation site loads images correctly
- [ ] Language switching swaps images properly
